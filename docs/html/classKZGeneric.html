<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Kolmogorov-Zurbenko Adaptive Filter: KZGeneric&lt; ValueT, SizeT, WinSizeT &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Kolmogorov-Zurbenko Adaptive Filter
   </div>
   <div id="projectbrief">Header-only library with implementation of                           Adaptive Kolmogorov-Zurbenko filter for                           different dimensions</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#pri-types">Private Types</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="classKZGeneric-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">KZGeneric&lt; ValueT, SizeT, WinSizeT &gt; Class Template Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div></div>
</div><!--header-->
<div class="contents">

<p>Base template class of Kolmogorov-Zurbenko filter with general parallel algorithm.  
 <a href="classKZGeneric.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="kza_8hpp_source.html">kza.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for KZGeneric&lt; ValueT, SizeT, WinSizeT &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classKZGeneric.png" usemap="#KZGeneric_3C_20ValueT_2C_20SizeT_2C_20WinSizeT_20_3E_map" alt=""/>
  <map id="KZGeneric_3C_20ValueT_2C_20SizeT_2C_20WinSizeT_20_3E_map" name="KZGeneric_3C_20ValueT_2C_20SizeT_2C_20WinSizeT_20_3E_map">
<area href="classKZ1D.html" title="Kolmogorov-Zurbenko 1D filter." alt="KZ1D&lt; ValueT, SizeT, WinSizeT &gt;" shape="rect" coords="0,56,239,80"/>
<area href="classKZ2D.html" title="Kolmogorov-Zurbenko 2D filter." alt="KZ2D&lt; ValueT, SizeT, WinSizeT &gt;" shape="rect" coords="249,56,488,80"/>
<area href="classKZA1D.html" title="Kolmogorov-Zurbenko 1D adaptive filter." alt="KZA1D&lt; ValueT, SizeT, WinSizeT &gt;" shape="rect" coords="0,112,239,136"/>
<area href="classKZA2D.html" title="Kolmogorov-Zurbenko 2D adaptive filter." alt="KZA2D&lt; ValueT, SizeT, WinSizeT &gt;" shape="rect" coords="249,112,488,136"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structKZGeneric_1_1ThreadData.html">ThreadData</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a7f03d3aed9e0faa419b41a6017e34106"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classKZGeneric.html#a7f03d3aed9e0faa419b41a6017e34106">set_iterations</a> (SizeT <a class="el" href="classKZGeneric.html#adaacee486e630bac3dfefc40cc348fb0">iterations</a>)</td></tr>
<tr class="memdesc:a7f03d3aed9e0faa419b41a6017e34106"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filter iterations setter.  <a href="classKZGeneric.html#a7f03d3aed9e0faa419b41a6017e34106">More...</a><br /></td></tr>
<tr class="separator:a7f03d3aed9e0faa419b41a6017e34106"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:aebad603d37eccca8bb1192d0d5cab0c4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classKZGeneric.html#aebad603d37eccca8bb1192d0d5cab0c4">KZGeneric</a> (SizeT <a class="el" href="classKZGeneric.html#adaacee486e630bac3dfefc40cc348fb0">iterations</a>)</td></tr>
<tr class="separator:aebad603d37eccca8bb1192d0d5cab0c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6282ad81505ebb88686e5d1d65e9b462"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classKZGeneric.html#a6282ad81505ebb88686e5d1d65e9b462">~KZGeneric</a> ()=default</td></tr>
<tr class="separator:a6282ad81505ebb88686e5d1d65e9b462"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f2637bf0c2507261de427d1d0cb4e09"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classKZGeneric.html#a3f2637bf0c2507261de427d1d0cb4e09">perform_single_iteration</a> (SizeT start_idx, SizeT end_idx)=0</td></tr>
<tr class="memdesc:a3f2637bf0c2507261de427d1d0cb4e09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Single iteration step of the filter algorithm for each thred. This method must be overridden by derived classes.  <a href="classKZGeneric.html#a3f2637bf0c2507261de427d1d0cb4e09">More...</a><br /></td></tr>
<tr class="separator:a3f2637bf0c2507261de427d1d0cb4e09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1558a333196d5e7dec1a42cc2e0b65b2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classKZGeneric.html#a1558a333196d5e7dec1a42cc2e0b65b2">perform_iterations</a> (std::function&lt; void()&gt; on_iteration_complete)</td></tr>
<tr class="memdesc:a1558a333196d5e7dec1a42cc2e0b65b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method runs iterations of the filter algorithm. At each iteration, parallel threads call <a class="el" href="classKZGeneric.html#a3f2637bf0c2507261de427d1d0cb4e09" title="Single iteration step of the filter algorithm for each thred. This method must be overridden by deriv...">perform_single_iteration()</a> on their piece of data. The threads are synchronized using a barrier that calls the on_iteration_complete() lambda function to synchronize the result of each thread.  <a href="classKZGeneric.html#a1558a333196d5e7dec1a42cc2e0b65b2">More...</a><br /></td></tr>
<tr class="separator:a1558a333196d5e7dec1a42cc2e0b65b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7a61b093aad839a2b3bdd232c82d989"><td class="memItemLeft" align="right" valign="top">WinSizeT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classKZGeneric.html#ad7a61b093aad839a2b3bdd232c82d989">window_left_bound</a> (SizeT win_center, WinSizeT half_win)</td></tr>
<tr class="memdesc:ad7a61b093aad839a2b3bdd232c82d989"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the left bound of a window with a given center location. If the left bound of the window is less than 0, then it is cut to 0. Whole window size is 2*half_window+1.  <a href="classKZGeneric.html#ad7a61b093aad839a2b3bdd232c82d989">More...</a><br /></td></tr>
<tr class="separator:ad7a61b093aad839a2b3bdd232c82d989"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8459c7f3487094d3971975941b64f66"><td class="memItemLeft" align="right" valign="top">WinSizeT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classKZGeneric.html#ab8459c7f3487094d3971975941b64f66">window_right_bound</a> (SizeT win_center, WinSizeT half_win, SizeT data_size)</td></tr>
<tr class="memdesc:ab8459c7f3487094d3971975941b64f66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the right bound of a window with a given center location. If the right bound of the window goes beyond the boundaries of the data array, then the right border is trimmed to the maximum index. Whole window size is 2*half_window+1.  <a href="classKZGeneric.html#ab8459c7f3487094d3971975941b64f66">More...</a><br /></td></tr>
<tr class="separator:ab8459c7f3487094d3971975941b64f66"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-attribs" name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:adaacee486e630bac3dfefc40cc348fb0"><td class="memItemLeft" align="right" valign="top">SizeT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classKZGeneric.html#adaacee486e630bac3dfefc40cc348fb0">iterations</a></td></tr>
<tr class="memdesc:adaacee486e630bac3dfefc40cc348fb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterations number.  <a href="classKZGeneric.html#adaacee486e630bac3dfefc40cc348fb0">More...</a><br /></td></tr>
<tr class="separator:adaacee486e630bac3dfefc40cc348fb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b7d6bfa09f6591d6b91e2e46bd593b0"><td class="memItemLeft" align="right" valign="top">SizeT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classKZGeneric.html#a8b7d6bfa09f6591d6b91e2e46bd593b0">task_size</a></td></tr>
<tr class="memdesc:a8b7d6bfa09f6591d6b91e2e46bd593b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data size to be processed.  <a href="classKZGeneric.html#a8b7d6bfa09f6591d6b91e2e46bd593b0">More...</a><br /></td></tr>
<tr class="separator:a8b7d6bfa09f6591d6b91e2e46bd593b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b81808c9da259855b4b8638c5f1dad4"><td class="memItemLeft" align="right" valign="top">SizeT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classKZGeneric.html#a3b81808c9da259855b4b8638c5f1dad4">threads_cnt</a></td></tr>
<tr class="memdesc:a3b81808c9da259855b4b8638c5f1dad4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of CPU cores available for multithreading.  <a href="classKZGeneric.html#a3b81808c9da259855b4b8638c5f1dad4">More...</a><br /></td></tr>
<tr class="separator:a3b81808c9da259855b4b8638c5f1dad4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54cd8b7d48960ded2dac1e13dac17ab1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTimer.html">Timer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classKZGeneric.html#a54cd8b7d48960ded2dac1e13dac17ab1">timer</a></td></tr>
<tr class="separator:a54cd8b7d48960ded2dac1e13dac17ab1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-types" name="pri-types"></a>
Private Types</h2></td></tr>
<tr class="memitem:a00b4fe43a3e7aef46e97b2d2c46883fe"><td class="memItemLeft" align="right" valign="top">typedef std::barrier&lt; std::function&lt; void()&gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classKZGeneric.html#a00b4fe43a3e7aef46e97b2d2c46883fe">barrier_t</a></td></tr>
<tr class="separator:a00b4fe43a3e7aef46e97b2d2c46883fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-methods" name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:aaca3bfd3e22a7be7354f8bce79dd0aa3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classKZGeneric.html#aaca3bfd3e22a7be7354f8bce79dd0aa3">worker</a> (<a class="el" href="structKZGeneric_1_1ThreadData.html">ThreadData</a> &amp;t_data, <a class="el" href="classKZGeneric.html#a00b4fe43a3e7aef46e97b2d2c46883fe">barrier_t</a> &amp;sync_iteration)</td></tr>
<tr class="memdesc:aaca3bfd3e22a7be7354f8bce79dd0aa3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thread main function.  <a href="classKZGeneric.html#aaca3bfd3e22a7be7354f8bce79dd0aa3">More...</a><br /></td></tr>
<tr class="separator:aaca3bfd3e22a7be7354f8bce79dd0aa3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cb655e45668f79c3a29aebf889f15ce"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classKZGeneric.html#a6cb655e45668f79c3a29aebf889f15ce">start_threads</a> (std::vector&lt; <a class="el" href="structKZGeneric_1_1ThreadData.html">ThreadData</a> &gt; &amp;th, <a class="el" href="classKZGeneric.html#a00b4fe43a3e7aef46e97b2d2c46883fe">barrier_t</a> &amp;sync_iteration)</td></tr>
<tr class="memdesc:a6cb655e45668f79c3a29aebf889f15ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function distributes the task between threads and starts them.  <a href="classKZGeneric.html#a6cb655e45668f79c3a29aebf889f15ce">More...</a><br /></td></tr>
<tr class="separator:a6cb655e45668f79c3a29aebf889f15ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;class ValueT, std::unsigned_integral SizeT, std::unsigned_integral WinSizeT&gt;<br />
class KZGeneric&lt; ValueT, SizeT, WinSizeT &gt;</div><p >Base template class of Kolmogorov-Zurbenko filter with general parallel algorithm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ValueT</td><td>type of data values </td></tr>
    <tr><td class="paramname">SizeT</td><td>type of data size </td></tr>
    <tr><td class="paramname">WinSizeT</td><td>type of window size </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a00b4fe43a3e7aef46e97b2d2c46883fe" name="a00b4fe43a3e7aef46e97b2d2c46883fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00b4fe43a3e7aef46e97b2d2c46883fe">&#9670;&nbsp;</a></span>barrier_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ValueT , std::unsigned_integral SizeT, std::unsigned_integral WinSizeT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::barrier&lt;std::function&lt;void()&gt; &gt; <a class="el" href="classKZGeneric.html">KZGeneric</a>&lt; ValueT, SizeT, WinSizeT &gt;::barrier_t</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aebad603d37eccca8bb1192d0d5cab0c4" name="aebad603d37eccca8bb1192d0d5cab0c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebad603d37eccca8bb1192d0d5cab0c4">&#9670;&nbsp;</a></span>KZGeneric()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ValueT , std::unsigned_integral SizeT, std::unsigned_integral WinSizeT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classKZGeneric.html">KZGeneric</a>&lt; ValueT, SizeT, WinSizeT &gt;<a class="el" href="classKZGeneric.html">::KZGeneric</a> </td>
          <td>(</td>
          <td class="paramtype">SizeT&#160;</td>
          <td class="paramname"><em>iterations</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iterations</td><td>number of filter iterations </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6282ad81505ebb88686e5d1d65e9b462" name="a6282ad81505ebb88686e5d1d65e9b462"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6282ad81505ebb88686e5d1d65e9b462">&#9670;&nbsp;</a></span>~KZGeneric()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ValueT , std::unsigned_integral SizeT, std::unsigned_integral WinSizeT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classKZGeneric.html">KZGeneric</a>&lt; ValueT, SizeT, WinSizeT &gt;::~<a class="el" href="classKZGeneric.html">KZGeneric</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a1558a333196d5e7dec1a42cc2e0b65b2" name="a1558a333196d5e7dec1a42cc2e0b65b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1558a333196d5e7dec1a42cc2e0b65b2">&#9670;&nbsp;</a></span>perform_iterations()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ValueT , std::unsigned_integral SizeT, std::unsigned_integral WinSizeT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classKZGeneric.html">KZGeneric</a>&lt; ValueT, SizeT, WinSizeT &gt;::perform_iterations </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; void()&gt;&#160;</td>
          <td class="paramname"><em>on_iteration_complete</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method runs iterations of the filter algorithm. At each iteration, parallel threads call <a class="el" href="classKZGeneric.html#a3f2637bf0c2507261de427d1d0cb4e09" title="Single iteration step of the filter algorithm for each thred. This method must be overridden by deriv...">perform_single_iteration()</a> on their piece of data. The threads are synchronized using a barrier that calls the on_iteration_complete() lambda function to synchronize the result of each thread. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">on_iteration_complete</td><td>Lambda function for threads results synchronization. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3f2637bf0c2507261de427d1d0cb4e09" name="a3f2637bf0c2507261de427d1d0cb4e09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f2637bf0c2507261de427d1d0cb4e09">&#9670;&nbsp;</a></span>perform_single_iteration()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ValueT , std::unsigned_integral SizeT, std::unsigned_integral WinSizeT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classKZGeneric.html">KZGeneric</a>&lt; ValueT, SizeT, WinSizeT &gt;::perform_single_iteration </td>
          <td>(</td>
          <td class="paramtype">SizeT&#160;</td>
          <td class="paramname"><em>start_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SizeT&#160;</td>
          <td class="paramname"><em>end_idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Single iteration step of the filter algorithm for each thred. This method must be overridden by derived classes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start_idx</td><td>Starting data index. </td></tr>
    <tr><td class="paramname">end_idx</td><td>Ending (inclusive) data index. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classKZ1D.html#a84a83c6ccba6b28c2d321a49450aea21">KZ1D&lt; ValueT, SizeT, WinSizeT &gt;</a>, <a class="el" href="classKZ2D.html#a4855760ad1724cb4b411a7de6685313b">KZ2D&lt; ValueT, SizeT, WinSizeT &gt;</a>, <a class="el" href="classKZA1D.html#a0b22703dccd4bc3cd0928359f1edb251">KZA1D&lt; ValueT, SizeT, WinSizeT &gt;</a>, and <a class="el" href="classKZA2D.html#a595e712d44886de83a4e97381789121c">KZA2D&lt; ValueT, SizeT, WinSizeT &gt;</a>.</p>

</div>
</div>
<a id="a7f03d3aed9e0faa419b41a6017e34106" name="a7f03d3aed9e0faa419b41a6017e34106"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f03d3aed9e0faa419b41a6017e34106">&#9670;&nbsp;</a></span>set_iterations()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ValueT , std::unsigned_integral SizeT, std::unsigned_integral WinSizeT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classKZGeneric.html">KZGeneric</a>&lt; ValueT, SizeT, WinSizeT &gt;::set_iterations </td>
          <td>(</td>
          <td class="paramtype">SizeT&#160;</td>
          <td class="paramname"><em>iterations</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Filter iterations setter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iterations</td><td>number of filter iterations </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6cb655e45668f79c3a29aebf889f15ce" name="a6cb655e45668f79c3a29aebf889f15ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cb655e45668f79c3a29aebf889f15ce">&#9670;&nbsp;</a></span>start_threads()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ValueT , std::unsigned_integral SizeT, std::unsigned_integral WinSizeT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classKZGeneric.html">KZGeneric</a>&lt; ValueT, SizeT, WinSizeT &gt;::start_threads </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structKZGeneric_1_1ThreadData.html">ThreadData</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>th</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classKZGeneric.html#a00b4fe43a3e7aef46e97b2d2c46883fe">barrier_t</a> &amp;&#160;</td>
          <td class="paramname"><em>sync_iteration</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function distributes the task between threads and starts them. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">th</td><td>Threads array. </td></tr>
    <tr><td class="paramname">sync_iteration</td><td>barrier to synchronize threads after each iteration. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad7a61b093aad839a2b3bdd232c82d989" name="ad7a61b093aad839a2b3bdd232c82d989"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7a61b093aad839a2b3bdd232c82d989">&#9670;&nbsp;</a></span>window_left_bound()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ValueT , std::unsigned_integral SizeT, std::unsigned_integral WinSizeT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">WinSizeT <a class="el" href="classKZGeneric.html">KZGeneric</a>&lt; ValueT, SizeT, WinSizeT &gt;::window_left_bound </td>
          <td>(</td>
          <td class="paramtype">SizeT&#160;</td>
          <td class="paramname"><em>win_center</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">WinSizeT&#160;</td>
          <td class="paramname"><em>half_win</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the left bound of a window with a given center location. If the left bound of the window is less than 0, then it is cut to 0. Whole window size is 2*half_window+1. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">win_center</td><td>Window center index. </td></tr>
    <tr><td class="paramname">half_win</td><td>Half-window size. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab8459c7f3487094d3971975941b64f66" name="ab8459c7f3487094d3971975941b64f66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8459c7f3487094d3971975941b64f66">&#9670;&nbsp;</a></span>window_right_bound()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ValueT , std::unsigned_integral SizeT, std::unsigned_integral WinSizeT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">WinSizeT <a class="el" href="classKZGeneric.html">KZGeneric</a>&lt; ValueT, SizeT, WinSizeT &gt;::window_right_bound </td>
          <td>(</td>
          <td class="paramtype">SizeT&#160;</td>
          <td class="paramname"><em>win_center</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">WinSizeT&#160;</td>
          <td class="paramname"><em>half_win</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SizeT&#160;</td>
          <td class="paramname"><em>data_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the right bound of a window with a given center location. If the right bound of the window goes beyond the boundaries of the data array, then the right border is trimmed to the maximum index. Whole window size is 2*half_window+1. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">win_center</td><td>Window center index. </td></tr>
    <tr><td class="paramname">half_win</td><td>Half-window size. </td></tr>
    <tr><td class="paramname">data_size</td><td>Data size. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaca3bfd3e22a7be7354f8bce79dd0aa3" name="aaca3bfd3e22a7be7354f8bce79dd0aa3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaca3bfd3e22a7be7354f8bce79dd0aa3">&#9670;&nbsp;</a></span>worker()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ValueT , std::unsigned_integral SizeT, std::unsigned_integral WinSizeT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classKZGeneric.html">KZGeneric</a>&lt; ValueT, SizeT, WinSizeT &gt;::worker </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structKZGeneric_1_1ThreadData.html">ThreadData</a> &amp;&#160;</td>
          <td class="paramname"><em>t_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classKZGeneric.html#a00b4fe43a3e7aef46e97b2d2c46883fe">barrier_t</a> &amp;&#160;</td>
          <td class="paramname"><em>sync_iteration</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Thread main function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t_data</td><td>Thread data. </td></tr>
    <tr><td class="paramname">sync_iteration</td><td>barrier to synchronize threads after each iteration. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="adaacee486e630bac3dfefc40cc348fb0" name="adaacee486e630bac3dfefc40cc348fb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adaacee486e630bac3dfefc40cc348fb0">&#9670;&nbsp;</a></span>iterations</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ValueT , std::unsigned_integral SizeT, std::unsigned_integral WinSizeT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SizeT <a class="el" href="classKZGeneric.html">KZGeneric</a>&lt; ValueT, SizeT, WinSizeT &gt;::iterations</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Iterations number. </p>

</div>
</div>
<a id="a8b7d6bfa09f6591d6b91e2e46bd593b0" name="a8b7d6bfa09f6591d6b91e2e46bd593b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b7d6bfa09f6591d6b91e2e46bd593b0">&#9670;&nbsp;</a></span>task_size</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ValueT , std::unsigned_integral SizeT, std::unsigned_integral WinSizeT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SizeT <a class="el" href="classKZGeneric.html">KZGeneric</a>&lt; ValueT, SizeT, WinSizeT &gt;::task_size</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Data size to be processed. </p>

</div>
</div>
<a id="a3b81808c9da259855b4b8638c5f1dad4" name="a3b81808c9da259855b4b8638c5f1dad4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b81808c9da259855b4b8638c5f1dad4">&#9670;&nbsp;</a></span>threads_cnt</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ValueT , std::unsigned_integral SizeT, std::unsigned_integral WinSizeT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SizeT <a class="el" href="classKZGeneric.html">KZGeneric</a>&lt; ValueT, SizeT, WinSizeT &gt;::threads_cnt</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Number of CPU cores available for multithreading. </p>

</div>
</div>
<a id="a54cd8b7d48960ded2dac1e13dac17ab1" name="a54cd8b7d48960ded2dac1e13dac17ab1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54cd8b7d48960ded2dac1e13dac17ab1">&#9670;&nbsp;</a></span>timer</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ValueT , std::unsigned_integral SizeT, std::unsigned_integral WinSizeT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTimer.html">Timer</a> <a class="el" href="classKZGeneric.html">KZGeneric</a>&lt; ValueT, SizeT, WinSizeT &gt;::timer</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="kza_8hpp_source.html">kza.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4
</small></address>
</body>
</html>
